# Pset 2

## Concept Questions

1. The set of contexts in NonceGeneration are a way to subdivide the space of generated nonces into groups based on the context that they correspond to. Each concept only keeps track of the generated nonces within its own category, and prevents repetitions among these nonces (but doesn't consider the nonces in the other concept categories). This suggests that the contexts are the shortURLBases (such as Tinyurl), which are bases that are shared among many shortened URLs--they are usually the names of URL shortening services. There needs to be multiple contexts because there could be many URL shortening services. This makes sense because then the corresponding nonces would be the actual link names (i.e. words or random letters) that accompany the shortUrlBases.  
2. The NonceGeneration must store sets of used nonces/strings because the generated nonces/strings are used to create shortened URLs, and by the principle, there cannot be repeats--this is because if there are repeats within a group sharing the same URL base, then that means multiple URLs would map to the same link, which would be bad. The abstraction function af(used strings) is: for every string in the set of used strings, the counter in the implementation corresponding to that string is 1. 
3. One advantage of using common dictionary words for the nonces generated by NonceGeneration is that the shortened URLs using these words are easier to remember, since common words are way more understandable and memorable than randomly generated sequences of letters and numbers. This makes sharing links easier as well--for example, if individuals need to manually type the link instead of copy pasting--and minimizes errors and miscommunications. One disadvantage is that limiting nonces to real words limits the number of available nonces to use, which puts a limit on the number of shortened links that can be generated and/or the maximum allowed expiration time of the currently existing links, since repeats are not allowed (so either new links can't be created, or old links need to expire more quickly to make room for new ones). The modified concept would be as follows:
   * **concept:** NonceGeneration [Context]
     * **purpose:** generate unique, real-word strings within a context
     * **principle:** each generate returns a real-word string not returned before for that context
     * **state:**
       * a set of Contexts with
         * a used set of Strings
         * a set of all possible words Dictionary
     * **actions:**
       * generate (context: Context) : (nonce: String)
         * effect selects a word from Dictionary that is not already used by this context; adds it to the used set and returns it

## Synchronization Questions

1. In Request.shortenUrl, the nonce = shortUrlSuffix does not exist yet (in fact, it will to be generated as a result of this request) and thus only the URL-shortening service (such as Tinyurl) shortUrlBase is a necessary parameter. Then, in register, both shortUrlBase and shortUrlSuffix exist as parameters, since the nonce has been generated after the previous request was made, and register requires both base and suffix to be entered (since both of these comprise the link that the sync caller wants to register). Therefore, for register, both of these parameters must be passed in.
2. When argument/result names are the same as the variable names, they can be omitted, since it's clear what purposes they serve. However, they can't be omitted all the time, or there could be potential misunderstandings. For example, if the result is simply a number or string (for example, 3600 in the setExpiry sync), then using that instead of the name (seconds) makes it very confusing. Similarly, sometimes the argument/result name is more general, while the variable name is specific to some implementation or case, and it's good to include both for maximal clarity.
3. The request action is included in the first two syncs but not the third one because requesting a link is an active part of generating and registering short URLs, while setting an expiry time is not a user-request-related action. Although it happens after a successful request to register a URL, it doesn't happen as a direct response to the user's request--it happens as a result of a URL being created, which doesn't directly tie to the user's request.
4. If the application only supported one domain name, bit.ly, then there would be a lot of changes to be more specific. Firstly, all instances of shortUrlBase in the parameters of Request.shortenUrl would be removed, since all shortUrlBases would be the same and can be hardcoded. Next, in generate, context: shortUrlBase should be context: "bit.ly". Finally, in register, shortUrlBase would be replaced with shortUrlBase: "bit.ly" as well. In summary, all instances of shortUrlBase would either be removed, or replaced with "bit.ly".  
5. The sync for expireUrl should be: 
   * sync expireUrl
   * when ExpiringResource.expireResource():(resource: shortUrl)
   * then UrlShortening.delete(shortUrl)
   
## Extending the Design

1. The two concepts I want to add are as follows:
   1. First of all, a concept that tracks the data related to accesses to a link. (This could include number of accesses, IP addresses of accesses, etc. I'm putting them all together for sake of modularity and the "ready for change" principle, and I'm assuming AccessData is a defined generic type that contains this information). The specifications of this concept are as follows:
      * **concept:** LinkAccessInfo [AccessData]
        * **purpose:** track information regarding accesses to a short URL
        * **principle:** after each lookup of a short URL, the information regarding accessess to that short URL is updated
        * **state:** a set of Recorders with
          * a shortUrl String
          * a set of AccessData for shortUrl String
        * **actions:** 
          * createRecorder(shortUrl: String)
            * **requires:** no recorder exists for shortUrl
            * **effects:** creates recorder for shortUrl with empty inputs for AccessData
          * update(shortUrl: String)
            * **requires:** Recorder exists for shortUrl
            * **effects:** update AccessData in the Recorder for shortUrl
          * getData(shortUrl: String, user: User): (AccessData)
            * **requires:** Recorder exists for shortUrl, User is an owner of shortUrl
            * **effects:** return AccessData in the Recorder for shortUrl
   2. Second of all, a concept that manages ownership of shorturl links, so that for each link, only the user(s) that own that link can view analytics on that link. (I know that usually, only one user can own each link; however, I want to make my specification more general, and if implementers of my concept want to add that restriction they can add an additional condition to the **requires** clauses of the actions). The specifications of this concept are as follows:
      * **concept:** UrlOwning [User]
        * **purpose:** control ownership of shortUrls and access to information about them
        * **principle:** users can request to view analytics on shortUrls; only users that own a shortUrl can view analytics on it, everyone else has denied access
        * **state:** a set of Users with
          * a set of shortUrls the User owns
        * **actions:** 
          * claimUrl(shortUrl: String, user: User)
            * **requires:** shortUrl exists
            * **effects:** adds shortUrl to list of shortUrls the User owns; give User owner permissions to shortUrl
          * getOwners(shortUrl: String): (set of Users)
            * **requires:** shortUrl exists and has at least one owner
            * **effects:** returns set of all owners Users associated with shortUrl
2. The three syncs are as follows:
   1. Sync 1:
    * **sync** initAnalytics
    * **when** 
      * Request.shortenUrl()
      * UrlShortening.register(): (shortUrl)
    * **where**
      * User is obtained from retrieving the caller of the register action for UrlShortening
    * **then**
      * LinkAccessInfo.createRecorder(shortUrl)
      * UrlOwning.claimUrl(shortUrl, User)
   2. Sync 2:
    * **sync** expandAnalytics
    * **when** 
      * UrlShortening.lookup (shortUrl): ()
    * **then** 
      * LinkAccessInfo.update(shortUrl)
   3. Sync 3:
    * **sync** lookupAnalytics
    * **when** Request.getData(shortUrl, user)
    * **then** 
      * UrlOwning.getOwners(shortUrl): (set of Users)
      * if user in set of Users:
        * LinkAccessInfo.getData(shortUrl, user)
      * else:
        * return.error("unauthorized")
3. Feature requests:
   1. Allowing users to choose their own short URLs: 
      1. This would be a good change to add. It would be useful because sometimes users may need this feature to make links more memorable, and it can be implemented while preserving modularity.
      2. Change 1: add an optional argument to Request.shortenUrl called "customSuffix" that allows users to input their desired suffix.
      3. Change 2: add a sync for validating the custom suffix (I would add the used customSuffixes to the set of used Strings corresponding to each Context)
         1. **sync** validateSuffix
         2. **when** Request.shortenUrl(shortUrlBase, targetUrl, customSuffix)
         3. **then** if isAvailable(customSuffix), UrlShortening.register(shortUrlSuffix: customSuffix, shortUrlBase, targetUrl), else return.error("suffix unavailable")
      4. Change 3: I would add a check to the current register sync for if the customSuffix parameter is used, and if it is then I would not activate the Nonce generation
   2. Using the “word as nonce” strategy to generate more memorable short URLs:
      1. This would be a good change to add. It would be useful because it makes links more memorable, and it can be implemented while preserving modularity.
      2. Change 1: add a dictionary (similar to the response to question 3 in part 1 of this assignment) of all available real words to the NonceGeneration concept, and modify the generate function such that it selects a word from this Dictionary that isn't already used by the context, instead of generating a random word/phrase.
   3. Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL:
      1. This would not be a good change to add. First of all, it would require a change to the LinkAccessInfo concept to take in targetUrl instead of shortUrl, which is a fundamental change. Also, this may not always be wanted--for example, if owners of a link use different shortUrls to abbreviate a link for different contexts (i.e. different groups of people), they may want to track those accesses separately, which can be doable by looking at shortUrl but not by looking at targetUrl. This feature can be implemented in a more modular way by creating separate concept that uses the LinkAccessInfo concept as a generic type but also looks at targetUrls instead of shortUrls. 
   4. Generate short URLs that are not easily guessed:
      1. This would be a good change to add. It would be useful because it makes links more secure and less hackable, and it can be implemented while preserving modularity.
      2. Change 1: for NonceGeneration, in the generate action, create a more secure random URL generator (i.e. using encryption, more randomized, etc.)
   5. Supporting reporting of analytics to creators of short URLs who have not registered as user:
      1. This would not be a good change to add. First of all, ownership and information access is based on the User generic type, so changing this would require a lot of changes to the pre-existing concepts and syncs. Also, it would be much harder to authenticate creators of shortUrls, which could be a potential security risk. 